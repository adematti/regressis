#!/usr/bin/env python
# coding: utf-8

import os
import logging

import healpy as hp
import numpy as np
import fitsio

from .utils import hp_in_box


logger = logging.getLogger('Footprint')


class Footprint(object):
    """
    Base class for footprint given as argument in PhotometricDataFrame.
    New footprint need to contain at least these minimal attributs and methods.
    """
    def __init__(self, nside=256):
        """
        Initialize :class:`Footprint` .

        Parameters
        ----------
        nside: int, default=256
            Give the resolution of the output masks.
        """
        self.nside = 256
        self.default_region = ['Footprint']


    def __call__(self, keyword):
            """
            Method that return mask for the a specific region need to be implemented in your new footprint.
            """
            raise NotImplementedError('Implement method "run" in your {}'.format(self.__class__.__name__))


    def get_keep_to_norm(self, keyword):
            """
            Method that return mask to compute mean density in a specific keyword region. Need to be implemented in your new footprint if you want to use PhotometricDataFrame.use_new_norm == True.
            """
            raise NotImplementedError('Implement method "run" in your {}'.format(self.__class__.__name__))


    def systematic_key_for_region(self, keyword):
            """
            Method that return systematic keyword for systematic plots in function of specific keyword region need to be implemented in your new footprint.
            """
            raise NotImplementedError('Implement method "run" in your {}'.format(self.__class__.__name__))


class DR9Footprint(Footprint):
    """
    Specific class for the Photometric footprint DR9 of the Legacy Imaging Surveys.
    It loads information about DESI / DR9 footprint and the different photometric footprints or region of interest.
    It is based on `Data/Legacy_Imaging_DR9_footprint_256.fits` which is built from the fracarea_12290 given by the pixweight
    generated by desitarget. DES imprint is extracted from an old file given by Anand (at DR8 release).
    This file is generated here /global/homes/e/edmondc/Target_Selection/Build_footprint_file/.

    Reference: https://www.legacysurvey.org/

    Name: North = MzLS, South = DECaLZ (without DES), Des = DES
    WARNING: ISSOUTH is everything with Dec. < 32.275
    """

    def __init__(self, nside=256, mask_lmc=False, clear_south=False, mask_around_des=False, desi_cut=False):
        """
        Initialize :class:`DR9Footprint` .

        Parameters
        ----------
        nside: int, default=256
            Give the resolution of the output masks.

        mask_lmc: bool, default=False
            Mask out the Large Magellanic Cloud, useful for QSO target selection.

        clear_south: bool, default=False
            Mask out disconnected area in the NGC South. This region will be not used in DESI and have small fraction of area covered and bad observational conditions.

        mask_around_des: bool, default=False
            Mask the border of the footprint around DES which is contained in South; useful for systematic weights and avoid strange area in the K-fold training. This zone will not be observed by DESI.

        desi_cut: bool, default=False
            Mask out the south part of the NGC with Dec. < -30. It is expected to be not observed with the nominal DESI Y5.
        """
        self.nside = nside
        self.mask_lmc = mask_lmc
        self.clear_south = clear_south
        self.mask_around_des = mask_around_des
        self.desi_cut = desi_cut
        logger.info(f'Load DR9 footprint with mask_lmc={self.mask_lmc}, clear_south={self.clear_south}, mask_around_des={self.mask_around_des} and desi_cut={self.desi_cut}')

        self.data = fitsio.read(os.path.join(os.path.dirname(__file__), '..', 'data', 'Legacy_Imaging_DR9_footprint_256.fits'))

        self.default_region = ['North', 'South', 'Des']
        self.available_region = ['North', 'South', 'Des', 'South_ngc', 'South_sgc',
                                 'South_mid', 'South_mid_ngc', 'South_mid_sgc', 'South_pole', 'Des_mid',
                                 'Global', 'Footprint']


    def update_map(self, pixmap):
        """
        Apply mask and ud_grade input pixmap.

        Parameters
        ----------
        pixmap: pixmap to return with mask at the correct nside.
        """
        if self.mask_lmc:
            pixmap[hp_in_box(256, [52, 120, -90, -50], inclusive=True)] = False

        if self.clear_south:
            pixmap[hp_in_box(256, [120, 150, -45, -10], inclusive=True) + hp_in_box(256, [150, 180, -45, -15], inclusive=True) + hp_in_box(256, [210, 240, -20, -12], inclusive=True)] = False

        if self.mask_around_des:
            mask_around_des = np.zeros(hp.nside2npix(256), dtype=bool)
            mask_around_des[hp_in_box(256, [-120, 0, -90, -18.5], inclusive=True) + hp_in_box(256, [0, 120, -90, -17.4], inclusive=True)] = True
            mask_around_des[self.data['ISDES']] = False
            pixmap[mask_around_des] = False

        if self.desi_cut: # restricted to DESI footprint
            pixmap[hp_in_box(self.nside, [0, 360, -90, -30])] = False

        if self.nside != 256:
            pixmap = hp.ud_grade(pixmap, self.nside, order_in='NESTED')

        return pixmap


    def get_full(self):
        """
        Return full DR9 footprint -> healpix map with :attr:`nside` in nested ordering.
        """
        return self.update_map(self.data['ISDR9'])


    def get_ngc_sgc(self):
        """
        Return NGC / SGC mask -> healpix map with :attr:`nside` in nested ordering.
        """
        return self.update_map(self.data['ISNGC']), self.update_map(self.data['ISSGC'])


    def get_imaging_surveys(self, ngc_sgc_split=False):
        """
        Extract the three photometric footprint

        Parameter
        ---------
        ngc_sgc_split: bool
            Split into NGC / SGC region.

        Return
        ------
        (North, South, Des) or (North, South_ngc, South_sgc, Des) if ngc_sgc_split=True -> healpix map with :attr:`nside` in nested ordering.
        """
        if ngc_sgc_split:
            return self.update_map(self.data['ISNORTH']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES'] & self.data['ISNGC']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES'] & self.data['ISSGC']), self.update_map(self.data['ISDES'])
        else:
            return self.update_map(self.data['ISNORTH']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES']), self.update_map(self.data['ISDES'])


    def get_elg_region(self, ngc_sgc_split=False):
        """
        Return North / South & DES ( -30 < Dec < 32.275) / DES (Dec. < -30) and split the South part in NGC / SGC part if required.

        Parameter
        ---------
        ngc_sgc_split: bool
            Split into NGC / SGC region.

        Return
        ------
        (North, South_mid, South_pole) or (North, South_mid_ngc, South_mid_sgc, South_pole) if ngc_sgc_split=True -> healpix map with :attr:`nside` in nested ordering.
        """
        dec, all_south = self.data['DEC'], self.data['ISSOUTH']

        south_mid = all_south.copy()
        south_mid[dec <= -30] = False

        south_pole = all_south.copy()
        south_pole[dec > -30] = False

        if ngc_sgc_split:
            return self.update_map(self.data['ISNORTH']), self.update_map(south_mid & self.data['ISNGC']), self.update_map(south_mid & self.data['ISSGC']), self.update_map(south_pole)

        return self.update_map(self.data['ISNORTH']), self.update_map(south_mid), self.update_map(south_pole)


    def __call__(self, keyword):
        """
        Healpix map with :attr:`nside` in nested ordering used to extract the keyword zone.

        Parameter
        ---------
        keyword: str
            Zone name to build the mask.
        """
        if keyword == 'Global' or keyword == 'Footprint':
            return self.get_full()
        elif keyword == 'North':
            return self.get_imaging_surveys()[0]
        elif keyword == 'South':
            return self.get_imaging_surveys()[1]
        elif keyword == 'South_ngc':
            return self.get_imaging_surveys(ngc_sgc_split=True)[1]
        elif keyword == 'South_sgc':
            return self.get_imaging_surveys(ngc_sgc_split=True)[2]
        elif keyword == 'Des':
            return self.get_imaging_surveys()[2]
        elif keyword == 'Des_mid':
            map = self.get_imaging_surveys()[2] & ~self.get_elg_region()[2]
        elif keyword == 'South_mid':
            return self.get_elg_region()[1]
        elif keyword == 'South_mid_ngc':
            return self.get_elg_region(ngc_sgc_split=True)[1]
        elif keyword == 'South_mid_sgc':
            return self.get_elg_region(ngc_sgc_split=True)[2]
        elif keyword == 'South_pole':
            return self.get_elg_region()[2]
        else:
            raise ValueError(f"call of {self.__class__.__name__} is not implemented for region: {keyword}")


    def get_keep_to_norm(self, keyword):
        """
        Build mask with :attr:`nside` in nested ordering used to extract the keyword zone used to evaluate the mean density of the sample.
        These regions are choosen in the middle of the NGC. Far from the galatic plane, eclipic pole and Sgr. Stream.

        Parameter
        ---------
        keyword: str
            Zone name to build the mask.
        """
        keep_to_norm = np.zeros(hp.nside2npix(self.nside), dtype=bool)
        if keyword == 'North':
            logger.info("Use (R.A., Dec.) box: [120, 240, 32.2, 40] to compute mean density")
            keep_to_norm[hp_in_box(self.nside, [120, 240, 32.2, 40], inclusive=True)] = True
        elif keyword in ['South', 'South_ngc', 'South_mid', 'South_mid_ngc']:
            logger.info("Use (R.A., Dec.) box: [120, 240, 24, 32.2] to compute mean density")
            keep_to_norm[hp_in_box(self.nside, [120, 240, 24, 32.2], inclusive=True)] = True
        else:
            logger.info("No specific area is used to compute mean density")
            keep_to_norm = np.ones(hp.nside2npix(self.nside), dtype=bool)
        return keep_to_norm


    def systematic_key_for_region(self, keyword):
        """
        Extract corresponding systematic keyword for systematic plots.

        Parameter:
        ----------
        keyword: str
            Zone name that we want to collect the corresponding keyword for systematic plots.
        """
        if keyword in ['South_ngc', 'South_sgc', 'South_mid', 'South_mid_ngc', 'South_mid_sgc']:
            return 'South'
        elif keyword in ['Des_mid', 'South_pole']:
            return 'Des'
        else:
            return keyword
