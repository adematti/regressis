#!/usr/bin/env python
# coding: utf-8

# Load information about DESI footprint and the different
# photometric footprints or region of interest.

# Data/Legacy_Imaging_DR9_footprint_256.fits is built from the fracarea_12290 given by the pixweight
# file generated by desitarget. DES imprint is extracted from an old file given by Anand.
# It is built in Target_Selection/Build_footprint_file/

import os
import logging

import healpy as hp
import numpy as np
import fitsio

from .utils import hp_in_box


logger = logging.getLogger('Footprint')


class Footprint(object):
    """

    """
    def __init__():
        self.nside = 256
        self.default_region = ['Footprint']


    def __call__(self, keyword):
            """
            Method that return mask for the a specific region need to be implemented in your new engine.
            """
            raise NotImplementedError('Implement method "run" in your {}'.format(self.__class__.__name__))

    def systematic_key_for_region(self, keyword):
            """
            Method that return systematic keyword for systematic plots in function of specific keyword region need to be implemented in your new engine.
            """
            raise NotImplementedError('Implement method "run" in your {}'.format(self.__class__.__name__))


class DR9Footprint(Footprint):
    """
    Specific class for the Photometric footprint DR9 of the Legacy Imaging Surveys.
    Reference: https://www.legacysurvey.org/
    Name: North = MzLS, South = DECaLZ (without DES), Des = DES
    WARNING: ISSOUTH is everything with Dec. < 32.275
    """

    def __init__(self, nside=256, mask_lmc=False, clear_south=False, mask_around_des=False, desi_cut=False):
        """
        Initialize :class:`DR9Footprint` .

        Parameters
        ----------
        nside: int, default=256
            Give the resolution of the output masks.

        mask_lmc: bool, default=False
            Mask out the Large Magellanic Cloud, useful for QSO target selection.

        clear_south: bool, default=False
            Mask out disconnected area in the NGC South. This region will be not used in DESI and have small fraction of area covered and bad observational conditions.

        mask_around_des: bool, default=False
            Mask the border of the footprint around DES which is contained in South; useful for systematic weights.
            # TODO: why???

        desi_cut: bool, default=False
            Mask out the south part of the NGC with Dec. < -30. It is expected to be not observed with the nominal DESI Y5.
        """
        self.nside = nside
        self.mask_lmc = mask_lmc
        self.clear_south = clear_south
        self.mask_around_des = mask_around_des
        self.desi_cut = desi_cut
        logger.info(f'Load DR9 footprint with mask_lmc={self.mask_lmc}, clear_south={self.clear_south}, mask_around_des={self.mask_around_des} and desi_cut={self.desi_cut}')

        self.data = fitsio.read(os.path.join(os.path.dirname(__file__), '..', 'data', 'Legacy_Imaging_DR9_footprint_256.fits'))

        self.default_region = ['North', 'South', 'Des']
        self.available_region = ['North', 'South', 'Des', 'South_ngc', 'South_sgc',
                                 'South_mid', 'South_mid_ngc', 'South_mid_sgc', 'South_pole', 'Des_mid',
                                 'Global', 'Footprint']


    def update_map(self, pixmap):
        """
        Apply mask and ud_grade input pixmap.

        Parameters
        ----------
        pixmap: pixmap to return with mask at the correct nside.
        """
        if self.mask_lmc:
            pixmap[hp_in_box(256, [52, 120, -90, -50], inclusive=True)] = False

        if self.clear_south:
            pixmap[hp_in_box(256, [120, 150, -45, -10], inclusive=True) + hp_in_box(256, [150, 180, -45, -15], inclusive=True) + hp_in_box(256, [210, 240, -20, -12], inclusive=True)] = False

        if self.mask_around_des:
            mask_around_des = np.zeros(hp.nside2npix(256), dtype=bool)
            mask_around_des[hp_in_box(256, [-120, 0, -90, -18.5], inclusive=True) + hp_in_box(256, [0, 120, -90, -17.4], inclusive=True)] = True
            mask_around_des[self.data['ISDES']] = False
            pixmap[mask_around_des] = False

        if self.desi_cut: # restricted to DESI footprint
            pixmap[hp_in_box(self.nside, [0, 360, -90, -30])] = False

        if self.nside != 256:
            pixmap = hp.ud_grade(pixmap, self.nside, order_in='NESTED')

        return pixmap


    def get_full(self):
        """
        Return full DR9 footprint -> healpix map with :attr:`nside` in nested ordering.
        """
        return self.update_map(self.data['ISDR9'])


    def get_ngc_sgc(self):
        """
        Return NGC / SGC mask -> healpix map with :attr:`nside` in nested ordering.
        """
        return self.update_map(self.data['ISNGC']), self.update_map(self.data['ISSGC'])


    def get_imaging_surveys(self, ngc_sgc_split=False):
        """
        Extract the three photometric footprint

        Parameter
        ---------
        ngc_sgc_split: bool
            Split into NGC / SGC region.

        Return
        ------
        (North, South, Des) or (North, South_ngc, South_sgc, Des) if ngc_sgc_split=True -> healpix map with :attr:`nside` in nested ordering.
        """
        if ngc_sgc_split:
            return self.update_map(self.data['ISNORTH']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES'] & self.data['ISNGC']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES'] & self.data['ISSGC']), self.update_map(self.data['ISDES'])
        else:
            return self.update_map(self.data['ISNORTH']), self.update_map(self.data['ISSOUTH'] & ~self.data['ISDES']), self.update_map(self.data['ISDES'])


    def get_elg_region(self, ngc_sgc_split=False):
        """
        Return North / South & DES ( -30 < Dec < 32.275) / DES (Dec. < -30) and split the South part in NGC / SGC part if required.

        Parameter
        ---------
        ngc_sgc_split: bool
            Split into NGC / SGC region.

        Return
        ------
        (North, South_mid, South_pole) or (North, South_mid_ngc, South_mid_sgc, South_pole) if ngc_sgc_split=True -> healpix map with :attr:`nside` in nested ordering.
        """

        dec, all_south = self.data['DEC'], self.data['ISSOUTH']

        south_mid = all_south.copy()
        south_mid[dec <= -30] = False

        south_pole = all_south.copy()
        south_pole[dec > -30] = False

        if ngc_sgc_split:
            return self.update_map(self.data['ISNORTH']), self.update_map(south_mid & self.data['ISNGC']), self.update_map(south_mid & self.data['ISSGC']), self.update_map(south_pole)

        return self.update_map(self.data['ISNORTH']), self.update_map(south_mid), self.update_map(south_pole)


    def __call__(self, keyword):
        """
        Extract the healpix map with :attr:`nside` in nested ordering used to extract the keyword zone.

        Parameter
        ---------
        keyword: str
            Zone name to build the mask.

        """
        if keyword == 'Global' or keyword == 'Footprint':
            return self.get_full()
        elif keyword == 'North':
            return self.get_imaging_surveys()[0]
        elif keyword == 'South':
            return self.get_imaging_surveys()[1]
        elif keyword == 'South_ngc':
            return self.get_imaging_surveys(ngc_sgc_split=True)[1]
        elif keyword == 'South_sgc':
            return self.get_imaging_surveys(ngc_sgc_split=True)[2]
        elif keyword == 'Des':
            return self.get_imaging_surveys()[2]
        elif keyword == 'Des_mid':
            map = self.get_imaging_surveys()[2] & ~self.get_elg_region()[2]
        elif keyword == 'South_mid':
            return self.get_elg_region()[1]
        elif keyword == 'South_mid_ngc':
            return self.get_elg_region(ngc_sgc_split=True)[1]
        elif keyword == 'South_mid_sgc':
            return self.get_elg_region(ngc_sgc_split=True)[2]
        elif keyword == 'South_pole':
            return self.get_elg_region()[2]
        else:
            raise ValueError(f"call of {self.__class__.__name__} is not implemented for region: {zone_name}")


    def systematic_key_for_region(self, keyword):
        """
        Extract corresponding systematic keyword for systematic plots.

        Parameter:
        ----------
        keyword: str
            Zone name that we want to collect the corresponding keyword for systematic plots.
        """
        if keyword in ['South_ngc', 'South_sgc', 'South_mid', 'South_mid_ngc', 'South_mid_sgc']:
            return 'South'
        elif keyword in ['Des_mid', 'South_pole']:
            return 'Des'
        else:
            return keyword
